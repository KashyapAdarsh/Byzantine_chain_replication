from logger import *
from classes import *
from constants import *
from replica import Replica
import uuid
import time
import sys
import nacl.encoding
import nacl.signing

class Olympus(process):

	def setup(init_config):
		self.init_config = init_config
		self.client_config = dict()
		self.clients = dict()
		self.client_list = []
		self.signing_keys = dict()
		self.failure_config = None
		self.verify_keys = dict()
		self.olympus_id = uuid.uuid4()
		self.configs = []
		self.replica_list = []
		self.active_config = None
		self.wedged_data = dict()
		self.data_store = dict()
		self.head_timeout = init_config[HEAD_TIMEOUT]
		self.nonhead_timeout = init_config[NONHEAD_TIMEOUT]
		self.head = None
		self.tail = None
		self.no_of_replicas = (2 * float(init_config[TOLERENCE])) + 1 # 2t+1
		self.no_of_clients = float(init_config[CLIENT_COUNT])
		self.all_replicas_spawned = False
		self.privateKey = None
		self.INFO = "[OLYMPUS] "
		log.info(self.INFO + "Olympus setup complete, assigned ID :" + str(self.olympus_id))

	def run():
		log.info(self.INFO + "Running test case : " + str(init_config["test_case_name"]))
		make_new_replica()

		# Wait untill all the clients register with olympus
		# await(len(self.clients) == int(self.no_of_clients))

		await(len(self.clients) == self.no_of_clients)

		# Sends client info to everyone
		for replica in self.replica_list:
			send(("client_details", self.clients), to=replica)

		# Tell clients that replicas are ready and also send current 
		# active configuration details.
		for client in self.client_list:
			send(("replicas_ready", active_config),to=client)

		# Send fault injection to everyone
		send_fault_injection()

		# We need to keep olympus alive
		is_alive = False
		await(is_alive == True)

	def make_new_replica():
		config_id = uuid.uuid4()
		spawn_replicas()
		active_config = config_id
		configs.append(config_id)

	def send_fault_injection():
		failure = None
		failure_key = None
		for key in list(self.init_config.keys()):
			if (key.startswith("failures[0")):
				failure = init_config[key]
				failure_key = key
				break

		# We don't have failures for this configuration
		if (failure == None):
			return

		# Replica to which we need to send fault object
		replica_index = int(failure_key.split(',')[1].strip().replace(']',''))
		
		failure = failure.split(',')
		msg_count = int(failure[1].replace(')', '').strip())
		opt = failure[2].replace('(','').replace(')','').strip()
		client_index = int(failure[0].split('(')[1].strip())
		shuttle_type = failure[0].split('(')[0].strip()

		if (client_index > len(self.client_list) or replica_index > len(self.replica_list)):
			log.error(self.INFO +"Error processing failure injection.")
			return

		self.failure_config = FailureConfig(self.client_list[client_index-1], \
											msg_count, shuttle_type, opt)
		log.info(self.INFO + "Sending failure config to " + str(self.replica_list[replica_index-1]))
		send(("failure_config",self.failure_config), to=self.replica_list[replica_index-1])


	# This method spawns required number of replica and it handles two cases
	# 1) If we are spawning for the first time
	# 2) If we are reconfiguring
	def spawn_replicas():
		if not self.replica_list:
			log.info(self.INFO + "Creating new replicas.")

			replica_hosts = self.init_config[REPLICA_HOSTS].split(';')

			# Running clients on different hosts
			for i in range(int(self.no_of_replicas)):
				node = 'Node' + str(replica_hosts[i])
				self.replica_list.append(new(Replica, agrs=(), at=node))

			self.replica_list = [next(iter(replica)) for replica in self.replica_list]

			generate_keys()

			for index in range(len(self.replica_list)):
				replica_config = make_replica_config(replica_list[index], \
											signing_keys[replica_list[index]])
				replica_config = add_head_tail(index, replica_config)
				
				# Add some details to replica config
				replica_config.head_id = self.replica_list[0]
				replica_config.head_timeout = self.head_timeout
				replica_config.nonhead_timeout = self.nonhead_timeout

				setup(self.replica_list[index],[replica_config])
				start(self.replica_list[index])

			self.all_replicas_spawned = True
			
			replica_chain = ""
			for replica in self.replica_list:
				replica_chain += str(replica) + '-->'
			log.info(self.INFO + "Chain---> " + replica_chain)			

		else:
			log.info(self.INFO + "Deleting old replicas.")
			pass
		pass

	# This method will generate signing keys and encoded verification keys for
	# all the replicas. We save it into two seperate dict.
	# <replica_id, signing key> and <replica_id, verification key>

	def generate_keys():
		log.info(self.INFO + "Generating signing and verification keys.")

		for replica in self.replica_list:
			signing_key = nacl.signing.SigningKey.generate()
			verify_key = signing_key.verify_key
			verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
			signing_keys[replica] = signing_key
			verify_keys[replica] = verify_key_hex

	# This method creates a configuration object for a replica
	# @arg - specific signing key, that will be sent only to this replica

	def make_replica_config(id, signing_key):
		replica_config = ReplicaConfig(id, self.verify_keys, signing_key,\
						 self.data_store, ACTIVE, self.replica_list, self.init_config[TESTCASE_NAME])
		return replica_config

	# This method adds head and tail info for every replicaconfig object created.
	# We add next and prev replica details for the current replica.
	# we also set is_head and is_tail for current replica here

	def add_head_tail(replica_index, replica_config):
		if (replica_index == 0):
			log.info(self.INFO + "Head is " + str(replica_list[replica_index]))
			replica_config.is_head = True
			self.head = self.replica_list[replica_index]
			# If we have only one replica, then both head and tail are same
			if (len(self.replica_list) == 1):
				log.info(self.INFO + "Tail is " + str(replica_list[replica_index]))
				replica_config.is_tail = True
				self.tail = self.replica_list[replica_index]
			replica_config.next_replica_id = self.replica_list[replica_index + 1]
		elif (replica_index == len(self.replica_list) - 1):
			log.info(self.INFO + "Tail is " + str(replica_list[replica_index]))
			replica_config.is_tail = True
			self.tail = self.replica_list[replica_index]
			replica_config.prev_replica_id = self.replica_list[replica_index - 1]
		else:
			replica_config.next_replica_id = self.replica_list[replica_index + 1]
			replica_config.prev_replica_id = self.replica_list[replica_index - 1]

		return replica_config

	# This method will send required details to the client
	def send_client_config(client):
		conf = ClientConfig(self.verify_keys, self.replica_list, int(self.init_config[TOLERENCE]))
		conf.head_id = self.head
		conf.tail_id = self.tail
		log.info(self.INFO + "Sending replica details to client " + str(client))
		send(("client_config", conf), to=client)

	################### Receivers for olympus ######################

	# Receiver for registering client with olympus.
	def receive(msg=("register_client", client_id, client_key), from_=c):
		log.info(self.INFO + "Received request to register client : " + str(client_id))
		self.clients[client_id] = client_key
		self.client_list.append(client_id)
		await(self.all_replicas_spawned == True)
		send_client_config(c)

	def receive(msg=("is_config_changed", config_id), from_=c):
		log.info(self.INFO + "Received config change check request from client " + str(c))
		is_changed = False
		if (self.active_config != config_id):
			is_changed = True

		send(("config_change_result", is_changed), to=c)