from logger import *
from classes import *
from constants import *
from replica import Replica
import uuid
import time
import sys
import nacl.encoding
import nacl.signing

class Olympus(process):

	def setup(init_config):
		self.client_config = dict()
		self.clients = dict()
		self.signing_keys = dict()
		self.verify_keys = dict()
		self.olympus_id = uuid.uuid4()
		self.configs = []
		self.replica_list = None
		self.active_config = None
		self.wedged_data = dict()
		self.data_store = dict()
		self.head_timeout = init_config[HEAD_TIMEOUT]
		self.nonhead_timeout = init_config[NONHEAD_TIMEOUT]
		self.head = None
		self.no_of_replicas = (2 * float(init_config[TOLERENCE])) + 1 # 2t+1
		self.no_of_clients = float(init_config[CLIENT_COUNT])
		self.privateKey = None
		self.INFO = "[OLYMPUS] "
		log.info(self.INFO + "Olympus setup complete, assigned ID :" + str(self.olympus_id))

	def run():
		make_new_replica()

		# Wait untill all the clients register with olympus
		await(len(self.clients) == self.no_of_clients)
		log.info(self.INFO + "All clients registered successfully.")

	def make_new_replica():
		config_id = uuid.uuid4()
		spawn_replicas()
		active_config = config_id
		configs.append(config_id)

	# This method spawns required number of replica and it handles two cases
	# 1) If we are spawning for the first time
	# 2) If we are reconfiguring

	def spawn_replicas():
		if (self.replica_list == None):
			log.info(self.INFO + "Creating new replicas.")
			self.replica_list = new(Replica, num=int(self.no_of_replicas))
			# Converting set to list
			self.replica_list = list(self.replica_list)

			generate_keys()

			for index in range(len(self.replica_list)):
				replica_config = make_replica_config(replica_list[index], \
											signing_keys[replica_list[index]])
				replica_config = add_head_tail(index, replica_config)
				setup(self.replica_list[index],[replica_config])
				start(self.replica_list[index])
		else:
			log.info(self.INFO + "Deleting old replicas.")
			pass
		pass

	# This method will generate signing keys and encoded verification keys for
	# all the replicas. We save it into two seperate dict.
	# <replica_id, signing key> and <replica_id, verification key>

	def generate_keys():
		log.info(self.INFO + "Generating signing and verification keys.")

		for replica in self.replica_list:
			signing_key = nacl.signing.SigningKey.generate()
			verify_key = signing_key.verify_key
			verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
			signing_keys[replica] = signing_key
			verify_keys[replica] = verify_key_hex

	# This method creates a configuration object for a replica
	# @arg - specific signing key, that will be sent only to this replica

	def make_replica_config(id, signing_key):
		replica_config = ReplicaConfig(id, self.verify_keys, signing_key, self.clients, self.data_store, "ACTIVE")
		return replica_config

	# This method adds head and tail info for every replicaconfig object created.
	# We add next and prev replica details for the current replica.
	# we also set is_head and is_tail for current replica here

	def add_head_tail(replica_index, replica_config):
		if (replica_index == 0):
			replica_config.is_head = True
			replica_config.next_replica_id = self.replica_list[replica_index + 1]
		elif (replica_index == len(self.replica_list) - 1):
			replica_config.is_tail = True
			replica_config.prev_replica_id = self.replica_list[replica_index - 1]
		else:
			replica_config.next_replica_id = self.replica_list[replica_index + 1]
			replica_config.prev_replica_id = self.replica_list[replica_index - 1]

		return replica_config

	################### Receivers for olympus ######################

	# Receiver for registering client with olympus.
	def receive(msg=("register_client", client_id, client_key), from_=c):
		log.info(self.INFO + "Received request to register client : " + str(client_id))
		self.clients[client_id] = client_key