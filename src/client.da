from logger import *
from classes import *
from constants import *
from olympus import Olympus
import time
import sys
import pickle
import nacl.encoding
import nacl.signing
import uuid

class Client(process):
	def setup(olympus, id, init_config, work_load):
		self.client_id = id
		self.signing_key = None
		self.work_load = work_load
		self.current_work_load = 0
		self.msg_details = dict()
		self.replica_head = None
		self.replica_tail = None
		self.replica_keys = None
		self.verify_key = None
		self.replica_list = None
		self.olympus = olympus
		self.retransmit_result = dict()
		self.timeout = float(init_config[CLIENT_TIMEOUT])
		self.INFO = "["+str(self.client_id).replace('>', "").replace('<', '')+"] "
		log.info(self.INFO + "Setup complete")

	def run():
		generate_keys()
		register_with_client()
		
		# For various operations, we send next operation only after receiving
		# response for current operation

		# We sleep for small time so that olympus can share client details to
		# everyone by then.
		time.sleep(2)

		for load in work_load:
			msg_id = uuid.uuid4()
			operation = make_operation(msg_id, load)
			if (operation == None):
				continue
			send_request(operation, "new")

	# This method will register a client to olympus
	def register_with_client():
		verify_key_hex = generate_keys()
		send(("register_client",self.client_id, verify_key_hex), to=self.olympus)
		# Wait untill we recieve back data from olympus
		await(self.replica_keys != None)

	# This method generates a signing key and verification key
	# verification key that we send to olympus is encoded before sending
	
	def generate_keys():
		self.signing_key = nacl.signing.SigningKey.generate()
		self.verify_key = self.signing_key.verify_key
		verify_key_hex = self.verify_key.encode(encoder=nacl.encoding.HexEncoder)
		return verify_key_hex

	# This method identifies type of operation that client has to request next
	# and make an operation object with all necessary details like 
	# TYPE - Get, put, append or slice
	# and key, values for each operation

	def make_operation(msg_id, opt):
		operation = None
		# Identify put, append or slice workloads
		if ((PUT in opt) or (APPEND in opt) or (SLICE in opt)):
			temp = opt[opt.index('(') + 1:opt.index(')')].split(',')
			key = temp[0].replace("'", "").strip()
			value = temp[1].replace("'", "").strip()
			operation = Operation(opt[0:opt.index('(')].strip(), msg_id, \
											Data(key, value), self.client_id)
		# Identifies get workload
		elif (GET in opt):
			value = opt[opt.index('(') + 1:opt.index(')')].replace("'", "").strip()
			operation = Operation(GET, msg_id, Data(None, value), self.client_id)

		# Pseudorandom operations
		else :
			pass

		return operation

	# This method sends request for the first time or if timesout
	# then it sends retransmission request as well.

	def send_request(operation, type):
		# Sending a new request

		if (type == "new"):
			log.info(self.INFO + "sending operation request to head with msgID : "\
					+str(operation.msg_id))
			msg_details[operation.msg_id] = ClientMessage(False, operation)
			send(("operation", operation, None, None), to=self.replica_head)
			
			if(await(self.msg_details[operation.msg_id].is_response_received == True)):
				continue
			elif (timeout(self.timeout)):
				log.info(self.INFO + "TIMEOUT")
				send_request(operation, "retransmission")
		else:
			self.msg_details[operation.msg_id].is_retransmited = True
			# Need to broadcast instead here
			broadcast_request(operation)

			# We wait untill all replicas send the result
			# TODO :  If we receive result from all then we need to verify
			if(await(len(self.retransmit_result) > 0)):
				log.info(self.INFO + "Received a succesfull retransmission result from " + \
													str(list(self.retransmit_result.keys())[0]))
				self.msg_details[operation.msg_id].is_response_received == True
				# Better to print result after verification
				if (verify_result(self.retransmit_result[list(self.retransmit_result.keys())[0]]) is False):
					log.info(self.INFO + "Result verification failed, need to reconfigure")
					return
				else:
					log.info(self.INFO + "Retransmission result : " + str(self.retransmit_result[list(self.retransmit_result.keys())[0]].result))
			elif (timeout(self.timeout)):
				log.info(self.INFO + "Retransmission timed out, we did not receive any successful result. sending reconfig request to olympus")
				#send_request(operation, "retransmission")

	# This method is used by client to verify the results received.

	def verify_result(response):
		log.info(self.INFO + "Verifying result.")
		index = 0
		prev_res = None

		for statement in response.result_proof:
			verify_key = nacl.signing.VerifyKey(self.replica_keys[self.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)
			index += 1
			res = pickle.loads(verify_key.verify(statement))

			if (prev_res is not None and (prev_res.operation.type != res.operation.type or \
				prev_res.operation.data.key != res.operation.data.key or \
				prev_res.operation.data.value != res.operation.data.value or \
				prev_res.operation.msg_id != res.operation.msg_id or \
				prev_res.operation.client_id != res.operation.client_id or \
				prev_res.result != res.result)):
				return False

			prev_res = res

		log.info(self.INFO + "Verification of result succesful.")
		return True

	def broadcast_request(operation):
		# This will broadcast the retransmission to all replicas
		for replica, val in self.replica_keys.items():
			log.info(self.INFO + "sending retransmission request to replica " +str(replica)+" for msgID : "\
					+str(operation.msg_id))
			send(("retransmit_operation",operation, None, None), to=replica)
			self.retransmit_result = dict()

	######## Receivers in client #########

	def receive(msg=("client_config", config)):
		log.info(self.INFO + "Received replica details from olympus")
		self.replica_head = config.head_id
		self.replica_tail = config.tail_id
		self.replica_keys = config.replicas
		self.replica_list = config.replica_list

	# Receiver for result in client.
	# This has to verify the result and stuff

	def receive(msg=("result", response), from_=r):
		# This receives results when it is normal
		if (self.msg_details[response.msg_id].is_retransmited == False):
			log.info(self.INFO + "Received result for msg " + str(response.msg_id))

			if(verify_result(response) == False):
				log.info(self.INFO + "Result verification failed, asking olympus to reconfigure")
				return

			log.info(self.INFO + "Result verified for msg "+ str(response.msg_id) + \
					" and the result is : " + str(response.result))
			msg_details[response.msg_id].is_response_received = True
		# This receives the result through retransmit
		else :
			log.info(self.INFO + "Received result for retransmission of " + \
				str(response.msg_id) + " from : " + str(r))
			# We will add result to dict only if it is success, if we receive success result 
			# from alteast one replica, then we are good

			if (response.result is not ERROR):
				self.retransmit_result[r] = response