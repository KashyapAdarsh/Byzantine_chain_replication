from logger import *
from classes import *
from constants import *
from olympus import Olympus
import time
import sys
import nacl.encoding
import nacl.signing
import uuid

class Client(process):
	def setup(olympus, id, init_config, work_load):
		self.client_id = id
		self.signing_key = None
		self.work_load = work_load
		self.current_work_load = 0
		self.msg_details = dict()
		self.replica_head = None
		self.replica_tail = None
		self.replica_keys = None
		self.verify_key = None
		self.olympus = olympus
		self.retransmit_result = dict()
		self.timeout = float(init_config[CLIENT_TIMEOUT])
		self.INFO = "["+str(self.client_id).replace('>', "").replace('<', '')+"] "
		log.info(self.INFO + "Setup complete")

	def run():
		generate_keys()
		register_with_client()
		
		# For various operations, we send next operation only after receiving
		# response for current operation

		for load in work_load:
			msg_id = uuid.uuid4()
			operation = make_operation(msg_id, load)
			if (operation == None):
				continue
			send_request(operation, "new")

	# This method will register a client to olympus
	def register_with_client():
		verify_key_hex = generate_keys()
		send(("register_client",self.client_id, verify_key_hex), to=self.olympus)
		# Wait untill we recieve back data from olympus
		await(self.replica_keys != None)

	# This method generates a signing key and verification key
	# verification key that we send to olympus is encoded before sending
	
	def generate_keys():
		self.signing_key = nacl.signing.SigningKey.generate()
		self.verify_key = self.signing_key.verify_key
		verify_key_hex = self.verify_key.encode(encoder=nacl.encoding.HexEncoder)
		return verify_key_hex

	# This method identifies type of operation that client has to request next
	# and make an operation object with all necessary details like 
	# TYPE - Get, put, append or slice
	# and key, values for each operation

	def make_operation(msg_id, opt):
		operation = None
		# Identify put, append or slice workloads
		if ((PUT in opt) or (APPEND in opt) or (SLICE in opt)):
			temp = opt[opt.index('(') + 1:opt.index(')')].split(',')
			key = temp[0].replace("'", "").strip()
			value = temp[1].replace("'", "").strip()
			operation = Operation(opt[0:opt.index('(')].strip(), msg_id, \
											Data(key, value), self.client_id)
		# Identifies get workload
		elif (GET in opt):
			value = opt[opt.index('(') + 1:opt.index(')')].replace("'", "").strip()
			operation = Operation(GET, msg_id, Data(None, value), self.client_id)

		# Pseudorandom operations
		else :
			pass

		return operation

	# This method sends request for the first time or if timesout
	# then it sends retransmission request as well.

	def send_request(operation, type):
		# Sending a new request

		if (type == "new"):
			log.info(self.INFO + "sending operation request to head with msgID : "\
					+str(operation.msg_id))
			msg_details[operation.msg_id] = ClientMessage(False, operation)
			send(("operation", operation, None, None), to=self.replica_head)
			
			if(await(self.msg_details[operation.msg_id].is_response_received == True)):
				continue
			elif (timeout(self.timeout)):
				log.info(self.INFO + "TIMEOUT")
				send_request(operation, "retransmission")
		else:
			self.msg_details[operation.msg_id].is_retransmited = True
			# Need to broadcast instead here
			broadcast_request(operation)

			# We wait untill all replicas send the result
			# TODO :  If we receive result from all then we need to verify
			if(await(len(self.retransmit_result) > 0)):
				log.info(self.INFO + "Received a succesfull retransmission result from " + \
													str(list(self.retransmit_result.keys())[0]))
				self.msg_details[operation.msg_id].is_response_received == True
				# Better to print result after verification
				verify_result()
			elif (timeout(self.timeout)):
				log.info(self.INFO + "Retransmission timed out, we did not receive any successful \
													result. sending reconfig request to olympus")
				#send_request(operation, "retransmission")

	def verify_result():
		pass


	def broadcast_request(operation):
		# This will broadcast the retransmission to all replicas
		for replica, val in self.replica_keys.items():
			log.info(self.INFO + "sending retransmission request to replica " +str(replica)+" for msgID : "\
					+str(operation.msg_id))
			send(("retransmit_operation",operation, None, None), to=replica)
			self.retransmit_result = dict()

	######## Receivers in client #########

	def receive(msg=("client_config", config)):
		log.info(self.INFO + "Received replica details from olympus")
		self.replica_head = config.head_id
		self.replica_tail = config.tail_id
		self.replica_keys = config.replicas

	# Receiver for result in client.
	# This has to verify the result and stuff

	def receive(msg=("result", response), from_=r):
		# This receives results when it is normal
		if (self.msg_details[response.msg_id].is_retransmited == False):
			log.info(self.INFO + "Received result for msg " + str(response.msg_id) \
													+ " : " + str(response.result))
			msg_details[response.msg_id].is_response_received = True
		# This receives the result through retransmit
		else :
			log.info(self.INFO + "Received result for retransmission of " + \
				str(response.msg_id) + " from : " + str(r))
			# We will add result to dict only if it is success, if we receive success result 
			# from alteast one replica, then we are good

			if (response.result == SUCCESS):
				self.retransmit_result[r] = response