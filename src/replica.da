from logger import *
from classes import *
from constants import *
from timer import CustomTimer
from util import *
import nacl.encoding
import nacl.hash
import pickle
import uuid
import time
import sys

class Replica(process):

	def setup(replica_config):
		# ReplicaConfig object
		self.config = replica_config
		self.msg_cache = dict()
		self.test = False
		self.history = []
		self.result_cache = dict()
		self.HASHER = nacl.hash.sha256
		self.INFO = "["+str(self.config.id).replace('>', "").replace('<', '')+"] "
		log.info(INFO +"Setup complete")

	# Need to define till when replicas are up and running

	def run():
		await(self.test == True)

	# This method verifies if client is valid

	def is_valid_client(c):
		if (c in self.config.clients):
			return True
		return False

	# This method is used by replicas to handle retransmission
	# We start a timer for every replica here and if we do not receive replicas
	# before that time then we reconfig. We have multiple cases here
	def handle_retransmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		
		# Case1 - result is cached
		if (operation.msg_id in result_cache):
			log.info(self.INFO + "Result for " + str(operation.msg_id) + " is saved, sending to client")
			response = ResponseObject(operation.msg_id, SUCCESS, self.result_cache[operation.msg_id])
			send(("result", response), to=sender)

		# Case2 - All other cases we will send request to head
		else:
			if (not self.config.is_head):
				# This will start a custom timer
				log.info(self.INFO + "Starting retransmission timer and sending request to head.")
				timer = CustomTimer(float(self.config.head_timeout), timer_callback, self.config.id, operation)
				# add the timer object to msg cache of this replica
				msg_cache[operation.msg_id] = timer
				send(("retransmit_operation", operation, None, None), to=self.config.head_id)
			else:
				# This will start a custom timer
				log.info (self.INFO + "Starting retransmission timer and starting order shuttle down the chain.")
				timer = CustomTimer(float(self.config.nonhead_timeout), timer_callback, self.config.id, operation)
				# add the timer object to msg cache of this replica
				msg_cache[operation.msg_id] = timer
				send_new_shuttle(operation, sender)

	# By the timer timer calls this callback, we should have recevied the result shuttle, stop this timer and
	# send response to client
	def timer_callback(id, operation):
		log.info(self.INFO +  "TIME OUT for replica " + str(id) + ", requesting olympus to reconfigure")
		# TODO - RECONFIGURE
		self.config.mode = IMMUTABLE
		log.info(self.INFO + "Mode changed to immutable")
		msg_cache[operation.msg_id].stop()

	# This method handles sending order shuttle down the chain
	# Here we have multiple cases based on if the replica is HEAD or TAIL

	def handle_transmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		# Case when replica is a head
		if (self.config.is_head):
			print_opt(operation)
			send_new_shuttle(operation, sender)
		# For any other case
		else:
			forward_shuttle(sender, result_shuttle, order_shuttle)

	# Helper to print		
	def print_opt(operation):
		opt = str(operation.type) + "("
		if (operation.data.key is not None): 
			opt += str(operation.data.key) + ","
		opt += str(operation.data.value)+")"
		
		log.info(self.INFO + "Received operation {" +opt+ "}" + " with msg id " +\
				str(operation.msg_id))

	# This method is used to verify the order proof before forwarding the shuttle
	# This is a common verification method for both result and order shuttle, 
	# it could be optimized

	def verify_shuttle(shuttle, shuttle_type):
		log.info(self.INFO + "Verifying " + shuttle_type)
		index = 0
		prev_res = None
		slot_or_res = []

		for statement in shuttle.statements:
			verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)
			index += 1
			res = pickle.loads(verify_key.verify(statement))

			if (prev_res is not None and (prev_res.operation.type != res.operation.type or \
				prev_res.operation.data.key != res.operation.data.key or \
				prev_res.operation.data.value != res.operation.data.value or \
				prev_res.operation.msg_id != res.operation.msg_id or \
				prev_res.operation.client_id != res.operation.client_id)):
				return False

			if (shuttle_type == "order_proof"):
				slot_or_res.append(res.slot)
			else:
				slot_or_res.append(res.result)

			prev_res = res

		# Slot has to be same for everyone if it is order proof or else
		# hash of result has to be same if it is res shuttle
		if (len(set(slot_or_res)) == 1):
			log.info(self.INFO + "Verification of "+ shuttle_type+" succesful")
			return True

		return False

	# This method will be used by replicas, to add its details and send the 
	# result
	# We have 2 cases : 
	#	1) If tail, send result to client and send result shuttle backwards
	#	2) If not tail, just add current result and forward it.

	def forward_shuttle(replica, result_shuttle, order_shuttle):
		operation = order_shuttle.operation
		slot =  order_shuttle.slot
		log.info(self.INFO + "Received shuttle from "+ str(replica))

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation)

		if (verify_shuttle(order_shuttle, "order_proof") == False):
			log.info(self.INFO + "Order shuttle verification failed, we need to ask olympus to reconfigure")
			return

		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
														operation, self.config.id)))
		
		if (verify_shuttle(result_shuttle, "result_proof") == False):
			log.info(self.INFO + "Order shuttle verification failed, we need to ask olympus to reconfigure")
			return

		result_shuttle.statements.append(sign_statement(ResultStatement(hash(result), \
														operation)))
		# add order shuttle to current replicas history
		history.append(order_shuttle)

		# We have to send result to client and start result shuttle message
		# backwards if it is a tail, else just forward the shuttle.
		if (self.config.is_tail):
			#log.info(self.INFO + "Sending result to client " + str(order_shuttle.client_id))
			# We make a response object before sending
			response = ResponseObject(order_shuttle.operation.msg_id, result, result_shuttle.statements)

			# Cache the result and send it back
			result_cache[result_shuttle.msg_id] = result_shuttle.statements

			# When result shuttle reached tail, if we have started timer then we send 
			# result to client and stop timer
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission, sending this to" + \
						  " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()
				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)

			send(("result", response), to=order_shuttle.client_id)
			# send result shuttle back
			send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.info(self.INFO + "Forwarding the shuttle to " + str(self.config.next_replica_id))
			send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	def send_result_backward(result_shuttle):
		# If result shuttle is valid, then we save it in cache
		if (verify_shuttle(result_shuttle, "result_proof_reverse_direction") == True):
			result_cache[result_shuttle.msg_id] = result_shuttle.statements
			log.info(self.INFO + "Result shuttle received for msg - " + str(result_shuttle.msg_id) + ", caching the result.")
			# We send result back till the head.
			if (not self.config.is_head):
				send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.info(self.INFO + "Result shuttle verification failed.")


	def sign_statement(statement):
		#return statement
		return self.config.signing_key.sign(pickle.dumps(statement))

	def hash(result):
		digest = HASHER(pickle.dumps(result), encoder=nacl.encoding.HexEncoder)
		return digest

	# This method will be used by the head first time to create new shuttle and
	# forward the same to next replica.

	def send_new_shuttle(operation, client):
		slot = get_next_slot()

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation)

		# Order shuttle..
		# Create order shuttle that goes down the chain
		order_shuttle =  OrderShuttle(slot, operation, client)
		# Add the first order statement
		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
													operation, self.config.id)))

		# Result shuttle..
		# Create a result shuttle that goes down the chain
		result_shuttle = ResultShuttle(client, operation.msg_id)
		# Add the first result statement
		# TODO - Need to encrypt result
		result_shuttle.statements.append(sign_statement(ResultStatement(hash(result), \
													operation)))

		# add order shuttle to current replicas history
		history.append(order_shuttle)

		# Same send will be used for both order and result shuttle down the chain
		log.info(self.INFO + "Forwarding the shuttle to " + str(self.config.next_replica_id))
		send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	# This method executes the operation on the datastore
	def execute_operation(operation):
		if (operation.type == PUT):
			self.config.data_store[operation.data.key] = [operation.data.value]
			return OK

		elif (operation.type == APPEND):
			if (operation.data.key in self.config.data_store):
				self.config.data_store[operation.data.key].append(operation.data.value)
				return OK
			return FAIL

		elif (operation.type == SLICE):
			start = int(operation.data.value.split(":")[0])
			end = int(operation.data.value.split(":")[1])

			if (operation.data.key not in self.config.data_store or start < 0 \
									or end > len(self.config.data_store)):
				return FAIL
			else:
				self.config.data_store[operation.data.key] = \
						self.config.data_store[operation.data.key][start : end]
				return OK

		elif (operation.type == GET):
			if (operation.data.value not in self.config.data_store):
				return NOT_PRESENT
			else:
				return self.config.data_store[operation.data.value]

		else:
			return ERROR


	def verify_result(result_shuttle):
		return True

	######### Receivers in replica ##########
	
	# This is a common receiver which does the following:
	# 1) Receives the main operation from client if it is a head
	# 2) Receives the order and result shuttle from prev replica
	# 3) Receive retransmission request from client
	# @args : operation - will be sent only by client for the first time,
	#		  other wise it is None, or during retransmission
	#		  shuttles - Will be sent by replicas when it is moving down the chain

	def receive(msg=("operation", operation, order_shuttle, result_shuttle), from_=sender):
		opt = None
		# This is the case when shuttle is moving down
		if (operation == None):
			opt = order_shuttle.operation
		else:
			opt = operation

		if (self.config.mode == ACTIVE):
			handle_transmission(operation=opt, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			# TODO - Need to send error statement to client
			pass

	def receive(msg=("retransmit_operation", operation, order_shuttle, result_shuttle), from_=sender):
		if (self.config.mode == ACTIVE):
			# If replica is head, if we receive operation request from any replica and we already started shuttle 
			# for this operation, we just ignore
			if (self.config.is_head and "Replica" in str(sender) and self.msg_cache[operation.msg_id] is not None):
				return

			handle_retransmission(operation=operation, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			pass
			# Need to send error statement to client directly


	# This is a receiver to receive result shuttle back from tail, we cache result here
	def receive(msg=('backward_result', result_shuttle), from_=r):
		if (self.config.mode == ACTIVE):

			# We have received this result shuttle as a part of reconfig, so timers are running
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission, sending this to" + \
						  " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()
				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)
				send(("result", response), to=result_shuttle.client_id)

			send_result_backward(result_shuttle)

# TODO FOR TOM : 

# re transmission has to be handled by starting timers and stuff for replicas.