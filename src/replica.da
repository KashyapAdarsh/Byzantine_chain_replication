from logger import *
from classes import *
from constants import *
from timer import CustomTimer
import copy
from util import *
import nacl.encoding
import nacl.hash
import pickle
import uuid
import time
import sys
import os

class Replica(process):

	# Main setup function that receives all the information required by replicas
	def setup(replica_config):
		# ReplicaConfig object
		self.config = replica_config
		self.client_counts = dict() # <client_id, msg_count>
		self.forward_msg_count = dict() # <client_id, forward_msg_count>, used for forwarded failure
		self.shuttle_count = 0	
		self.result_shuttle_count = 0
		self.failure_config_list = None
		self.failure_config = None
		self.msg_cache = dict()
		self.test = False
		self.history = []
		self.checkpoint = []
		self.slot_list = []
		self.latest_result = dict()
		self.data_store_backup = dict()
		self.olympus = None
		self.tamper_next_send = False # Used only during forwarded request trigger
		self.result_cache = dict()
		self.forward_shuttle_count = dict() # Used for shuttle failure trigger
		self.result_shuttle_count = dict()	# Used for result_shuttle failure trigger
		self.wedge_request_count = 0 # Used for wedged_request failure trigger
		self.checkpoint_count = 0 #Used for receipt of m'th checkpoint message failure trigger
		self.completed_checkpoint_count = 0 #Used for receipt of m'th completed checkpoint message failure trigger
		self.get_running_state_req_count = 0 #Used for receipt of m'th get_running_state message failure trigger
		self.catch_up_req_count = 0 #Used for receipt of m'th get_running_state message failure trigger
		self.HASHER = nacl.hash.sha256
		self.INFO = "["+str(self.config.id).replace('>', "").replace('<', '')+"] "
		log.info(INFO +"Setup complete")

	def run():
		await(self.test == True)

	# This method is used to initialize all the datastructures that keeps track of
	# various message counts for each client.
	def init_counts():
		# Adds count 0 for all clients
		for key in list(self.config.clients.keys()):
			self.client_counts[key] = 0
			self.forward_msg_count[key] = 0
			self.forward_shuttle_count[key] = 0
			self.result_shuttle_count[key] = 0
			self.latest_result[key] = None

	# This method verifies if client is valid
	def is_valid_client(c):
		if (c in self.config.clients):
			return True
		return False

	# This method is used by replicas to handle retransmission
	# We start a timer for every replica here and if we do not receive replicas
	# before that time then we reconfig. We have multiple cases here
	# 1) If result is cached already, we directly send it to client.
	# 2) If not we start a timer and forward that request to the head.

	def handle_retransmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		
		# Case1 - result is cached
		if (operation.msg_id in result_cache):
			log.info(self.INFO + "Result for " + str(operation.msg_id) + " is saved, sending to client" + str(sender))

			response = ResponseObject(operation.msg_id, self.result_cache[operation.msg_id].result, \
						self.result_cache[operation.msg_id])

			send(("result", response), to=sender)

		# Case2 - All other cases we will send request to head
		else:
			if (not self.config.is_head):
				# This will start a custom timer  
				log.info(self.INFO + "Starting retransmission timer and sending request to head for msg " \
						+ str(operation.msg_id))
				timer = CustomTimer(float(self.config.head_timeout), timer_callback, self.config.id, operation)
				# add the timer object to msg cache of this replica
				msg_cache[operation.msg_id] = timer
				send(("retransmit_operation", operation, None, None), to=self.config.head_id)
			else:
				# If head has already seen the message, but does not have result
				if (operation.msg_id in self.msg_cache):
					log.info(self.INFO + "Head has already seen the msg "+ str(operation.msg_id) +
						", so we don't start a new shuttle. Let's start timer andW wait for result shuttle to come back")
					timer = CustomTimer(float(self.config.nonhead_timeout), timer_callback, self.config.id, operation)
					# add the timer object to msg cache of this replica
					msg_cache[operation.msg_id] = timer
				else:
					# This will start a custom timer
					log.info(self.INFO + "Head has not seen the message at all.")
					log.info (self.INFO + "Starting retransmission timer and starting order shuttle down the chain for msg" \
							 + str(operation.msg_id))
					timer = CustomTimer(float(self.config.nonhead_timeout), timer_callback, self.config.id, operation)
					# add the timer object to msg cache of this replica
					msg_cache[operation.msg_id] = timer
					send_new_shuttle(operation, sender)

	# If this timer callback is invoked, our replicas are timedout on retransmission, so we
	# need to reconfigure. Currently it will also send a message for others to become immutable.

	def timer_callback(id, operation):
		log.error(self.INFO +  "TIME OUT for replica " + str(id) + " for msg"+ str(operation.msg_id) \
				+", requesting olympus to reconfigure")
		msg_cache[operation.msg_id].stop()
		notify_olympus(None)	
		
	# This method handles sending order shuttle down the chain
	# Here we have multiple cases based on if the replica is HEAD or Normal replicas

	def handle_transmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		if (self.config.mode == ACTIVE):
			# Case when replica is a head
			if (self.config.is_head):
				print_opt(operation)

				send_new_shuttle(operation, sender)

				# Checks if checkpoint has to be initiated.
				if (get_current_slot() % self.config.checkpoint_num == 0):
					log.info(self.INFO + "Checkpoint criteria satisfied.")
					# We intentionally send one less to truncate
					start_checkpoint_shuttle(get_current_slot() - 1)

			# For any other case
			else:
				forward_shuttle(sender, result_shuttle, order_shuttle)


	def start_checkpoint_shuttle(slot):
		if (self.config.mode == ACTIVE):
			log.info(self.INFO + "Starting checkpoint shuttle.")
			checkpoint_shuttle = CheckpointShuttle(slot)

			log.info(self.INFO + "Adding the hash of the datastore to the checkpoint proof")
			checkpoint_shuttle.statements.append(CheckpointStatement(hash(self.config.data_store)))

			#keeping count of number of checkpoints made to facilitate trigger when needed 
			if self.config.is_head:
				self.checkpoint_count += 1
			log.info(self.INFO + "Checkpoint count : " + str(self.checkpoint_count))

			send(("checkpoint_forward", checkpoint_shuttle), to=self.config.next_replica_id)


	def handle_checkpoint(type, checkpoint_shuttle):
		if (self.config.mode == ACTIVE):
			if (type == "forward"):
				log.info(self.INFO + "Adding the hash of the datastore to the checkpoint proof")
				checkpoint_shuttle.statements.append(CheckpointStatement(hash(self.config.data_store)))
				
				#keeping count of number of checkpoints made to facilitate trigger when needed 
				self.checkpoint_count += 1
				
				
				ret_index = is_failure_condition_satisfied(str("checkpoint_request"))
				if (self.failure_config_list is not None and ret_index != -1):
					dummy1, dummy2 = perform_failure_injection(checkpoint_shuttle, \
						None, self.config.replica_list.index(self.config.id), ret_index)	

				# If Not tail then keep sending it ahead
				if (not self.config.is_tail):
					send(("checkpoint_forward", checkpoint_shuttle), to=self.config.next_replica_id)
				else:
					self.completed_checkpoint_count += 1
					
					ret_index = is_failure_condition_satisfied(str("checkpoint_request"))
					if (self.failure_config_list is not None and ret_index != -1):
						dummy1, dummy2 = perform_failure_injection(checkpoint_shuttle, \
							None, self.config.replica_list.index(self.config.id), ret_index)

					process_checkpoint(checkpoint_shuttle)
					send(("checkpoint_reverse", checkpoint_shuttle), to=self.config.prev_replica_id)
			else:
				#keeping count of number of completed checkpoints made to facilitate trigger when needed 
				self.completed_checkpoint_count += 1
				
				ret_index = is_failure_condition_satisfied(str("checkpoint_request"))
				if (self.failure_config_list is not None and ret_index != -1):
					dummy1, dummy2 = perform_failure_injection(checkpoint_shuttle, \
						None, self.config.replica_list.index(self.config.id), ret_index)

				process_checkpoint(checkpoint_shuttle)
				if (not self.config.is_head):
					send(("checkpoint_reverse", checkpoint_shuttle), to=self.config.prev_replica_id)

	# This method processes the checkpoint, it does the following:
	# 1) Saves the checkpoint info
	# 2) Truncates the history

	def process_checkpoint(checkpoint_shuttle):
		
		log.info(self.INFO + "Verifying checkpoint." )
		if (len(checkpoint_shuttle.statements) < (int(len(self.config.replica_list) / 2) + 1)):
			log.error(self.INFO + "Verification of checkpoint failed, asking olympus to reconfigure")
			notify_olympus(None)
		else:
			log.info(self.INFO + "Checkpoint verification success.")

		# Truncating the history
		slot_to_truncate = checkpoint_shuttle.slot
		log.info(self.INFO + "Truncating the history till slot : " + str(slot_to_truncate))

		# Saving the checkpoint details
		log.info(self.INFO + "Saving the checkpoint information.")
		self.checkpoint.append(checkpoint_shuttle)

		# Truncating the history of the checkpoint
		for item in self.history[:]:
			if (item.slot <= slot_to_truncate):
				self.history.remove(item)
			else:
				break

	# Helper to print		
	def print_opt(operation):
		opt = str(operation.type) + "("
		if (operation.data.key is not None): 
			opt += str(operation.data.key) + ","
		opt += str(operation.data.value)+")"
		
		log.info(self.INFO + "Received operation {" +opt+ "}" + " with msg id " +\
				str(operation.msg_id))

	# This method is used to verify the order proof before forwarding the shuttle
	# This is a common verification method for both result and order shuttle, 
	# it could be optimized

	def verify_shuttle(shuttle, shuttle_type):
		log.info(self.INFO + "Verifying " + shuttle_type)
		index = 0
		prev_res = None
		slot_or_res = []

		if len(self.slot_list) >=2 and self.slot_list[-1] != self.slot_list[-2]+1:
			log.info(self.INFO + "holes in slots, sending false as verify shuttle result")
			return False

		# This will check if there is anything dropped from statements
		if (shuttle_type == "result_proof_reverse_direction"):
			# If result is going back then it should have all replicas statements
			if (len(shuttle.statements) != len(self.config.replica_list)):
				return False
		elif (shuttle_type == "order_proof" or shuttle_type == "result_proof"):
			# If shuttle is going down then it should have enough statements
			if (len(shuttle.statements) != (self.config.replica_list.index(self.config.id)) + 1):
				return False

		# This will check if all of them have same value
		for statement in shuttle.statements:
			verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)
			index += 1

			res = None
			try:
				res = pickle.loads(verify_key.verify(statement))
			except:
				log.error(self.INFO + "Signtaure error in the previous statement.")
				return False

			if (prev_res is not None and (prev_res.operation.type != res.operation.type or \
				prev_res.operation.data.key != res.operation.data.key or \
				prev_res.operation.data.value != res.operation.data.value or \
				prev_res.operation.msg_id != res.operation.msg_id or \
				prev_res.operation.client_id != res.operation.client_id)):
				return False

			if (shuttle_type == "order_proof"):
				slot_or_res.append(res.slot)
			else:
				slot_or_res.append(res.result)

			prev_res = res

		# Slot has to be same for everyone if it is order proof or else
		# hash of result has to be same if it is res shuttle
		if (len(set(slot_or_res)) == 1):
			log.info(self.INFO + "Verification of "+ shuttle_type +" succesful for msg "\
					+str(shuttle.operation.msg_id))
			return True

		return False

	# This is the main method that checks if it is the right time to trigger
	# a failure. We use failure configration object for details.

	def failure_config_list_lookup(shuttle_type):

		for index, item in enumerate(self.failure_config_list):
			if item.shuttle_type == shuttle_type:
				return index
		return -1

	def is_failure_condition_satisfied(msg):
		# If replica has received 'm' messages from a particular client
		if self.failure_config_list is None:
			return -1

		if (msg != "dummy"):
			log.info(self.INFO + "checking if failure injection criteria is satisfied for msg " + msg)
		
		ret_index = failure_config_list_lookup(CLIENT_REQUEST) 
		if (ret_index != -1):
			print(self.client_counts[self.failure_config_list[ret_index].client_id])
			print(self.failure_config_list[ret_index].msg_count)
			if(self.client_counts[self.failure_config_list[ret_index].client_id] == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.client_counts[self.failure_config_list[ret_index].client_id] = -100
				return ret_index

		# If replica has received 'm' forwarded message for a particular client
		ret_index = failure_config_list_lookup(FORWARDED_REQUEST) 
		if (ret_index != -1):
			if(self.forward_msg_count[self.failure_config_list[ret_index].client_id] == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.forward_msg_count[self.failure_config_list[ret_index].client_id] = -100
				return ret_index
		
		# We might have to reset count here, so that someother injection 
		# does not happen becuase of this condition
		ret_index = failure_config_list_lookup(SHUTTLE)
		'''	
			print("##################################", ret_index)
			print(self.config.clients.keys())
			print(self.failure_config_list[ret_index].client_id)
			print(self.client_counts)
			print(self.client_counts[self.failure_config_list[ret_index].client_id])
			print(self.failure_config_list[ret_index].msg_count)
		'''

		if (ret_index != -1):
			if(self.forward_shuttle_count[self.failure_config_list[ret_index].client_id] == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.forward_shuttle_count[self.failure_config_list[ret_index].client_id] = -100
				return ret_index
	
		ret_index = failure_config_list_lookup(RESULT_SHUTTLE) 
		if (ret_index != -1):
			if(self.result_shuttle_count[self.failure_config_list[ret_index].client_id] == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.result_shuttle_count[self.failure_config_list[ret_index].client_id] = -100
				return ret_index

		ret_index = failure_config_list_lookup(WEDGE_REQUEST) 
		if (ret_index != -1):
			if (self.wedge_request_count == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.wedge_request_count == -100
				return ret_index
		
		ret_index = failure_config_list_lookup(NEW_CONFIGURATION) 
		if (ret_index != -1):
			if (self.config.new_config_count == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.config.new_config_count = -100
				return ret_index

		ret_index = failure_config_list_lookup(CHECKPOINT) 
		if (ret_index != -1):
			if (self.checkpoint_count == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.checkpoint_count = -100
				return ret_index

		ret_index = failure_config_list_lookup(COMPLETED_CHECKPOINT) 
		if (ret_index != -1):
			if (self.completed_checkpoint_count == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.completed_checkpoint_count = -100
				return ret_index

		ret_index = failure_config_list_lookup(GET_RUNNING_STATE) 
		if (ret_index != -1):		
			if (self.get_running_state_req_count == self.failure_config_list[ret_index].msg_count):
				if (msg != "dummy"):
					self.get_running_state_req_count = -100
				return ret_index

		ret_index = failure_config_list_lookup(CATCH_UP) 
		if (ret_index != -1):		
			if (self.catch_up_req_count == self.failure_config_list.msg_count):
				if (msg != "dummy"):
					self.catch_up_req_count = -100
				return ret_index
		
		return -1

	# This method is the heart of failure injection, it does the following:
	# 1) Identifies the type of injection to be performed
	# 2) Since statements are signed, we need to decrypt them
	# 3) Add dummy operation to the respective position of the statement
	# 4) Above is repeated for both order and result shuttle

	def perform_failure_injection(order_shuttle, result_shuttle, index, failure_config_index):
		#log.info(self.INFO + "Performing failure injection for msg " + str(result_shuttle.msg_id))
		#log.info(self.INFO + "Performing failure injection for msg ")

		for idx, opt in enumerate(self.failure_config_list[failure_config_index].opt_type):
			log.info(self.INFO + " Performing failure operation : " + str(opt))
			# Here lets change the statement of index that is sent below in both order and result shuttle
			if (opt == CHANGE_OPT):
				log.info(self.INFO + "Changing the operation to get(X)")
				# Decrypting the order statement first
				verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
													encoder=nacl.encoding.HexEncoder)
				
				# If trigger type is result shuttle then order shuttle received will be None
				if (order_shuttle != None):
					res = pickle.loads(verify_key.verify(order_shuttle.statements[index]))
					# creating a wrong operation object
					operation = Operation(GET, res.operation.msg_id, Data(None, 'X'), res.operation.client_id)
					# Modifying original order statement of this replica to something wrong
					order_shuttle.statements[index] = sign_statement(OrderStatement(res.slot, \
															operation, self.config.id),False)
				# Decrypting the result statement first
				res = pickle.loads(verify_key.verify(result_shuttle.statements[index]))
				operation = Operation(GET, res.operation.msg_id, Data(None, 'X'), res.operation.client_id)			

				# Modifying original result statement of this replica to something wrong
				result_shuttle.statements[index] = sign_statement(ResultStatement(res.result,operation),False)
				
			elif (opt == DROP_RESULT):
				log.info(self.INFO + "Dropping head result statement.")
				# Drop the result statement of the head
				del result_shuttle.statements[0]

			elif (opt == CHANGE_RES):
				log.info(self.INFO + "Adding fake hash(OK) as result hash.")
				verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
													encoder=nacl.encoding.HexEncoder)
				# Decrypting the result statement first
				res = pickle.loads(verify_key.verify(result_shuttle.statements[index]))
				# We add hash of OK always
				print("ABRA : ",hash("abracadabra"))
				fake_result = hash("abracadabra")
				# Modifying original result statement of this replica to something wrong
				result_shuttle.statements[index] = sign_statement(ResultStatement(fake_result,res.operation),False)
			
			elif (opt == CRASH):
				log.info(self.INFO + "Performing crash injection and killing self")
				os._exit(-1)
			
			elif (opt == SLEEP):
				log.info(self.INFO + "Injection operation sleep. I am sleeping for sometime.")
				time.sleep(int(self.failure_config_list[failure_config_index].opt_arg[idx])) # put variable instead of static time

			elif (opt == TURNCATE_HISTORY):
				log.info(self.INFO + "turncate_history operation is being injected")
				print("turncate_history operation is being injected")
				n = int(self.failure_config_list[failure_config_index].opt_arg[idx]) # put variable instead of static number
				print ("failure index n", n)

				if len(self.history) < n:
					print("history not enough to turncate")
					log.error(self.INFO + "not enogh history to turncate")
				else:
					print("turncating history")
					log.info(self.INFO + "turncating history")
					for i in range(n):
						self.history.pop()

			elif (opt == DROP):
				log.info(self.INFO + "Drop failure is being injected")
				return True, True

			elif (opt == INCREMENT_SLOT):
				log.info(self.INFO + "increment slot failure is being injected")
				print("injecting increment slot failure")
				get_next_slot()

			elif (opt == INVALID_ORDER_SIG or opt == INVALID_RESULT_SIG):
				verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
													encoder=nacl.encoding.HexEncoder)
				if (order_shuttle != None):
					res = pickle.loads(verify_key.verify(order_shuttle.statements[index]))
					
					order_shuttle.statements[index] = sign_statement(res, True)

				# Decrypting the result statement first
				res = pickle.loads(verify_key.verify(result_shuttle.statements[index]))

				# Modifying original result statement of this replica to something wrong
				result_shuttle.statements[index] = sign_statement(res, True)

			elif (opt == DROP_CHECK_POINT):
				log.info(self.INFO + "Performing operation drop checkpoint statement")
				# order_shuttle is our checkpoint shuttle here
				t_1 = int(len(self.config.replica_list) / 2) + 1;
				for i in range(0,t_1):
					 del order_shuttle.statements[i]

			elif (opt == EXTRA_OP):
				log.info(self.INFO + "Performing failure injection extra_op")
				operation = Operation(PUT, None, Data("a","a"), None)
				execute_operation(operation, "normal")
				log.info(self.INFO + "Datastore : " + str(self.config.data_store))

			else:
				log.info(self.INFO + "Failure injection operation not recognized")


		return order_shuttle, result_shuttle

	# This method currently sends a message to all replicas asking them to become immutable.
	def notify_olympus(proof):
		send(("reconfigure", None), to=self.olympus)

	# This method will be used by replicas, to add its details and send the 
	# result
	# We have 2 cases : 
	#	1) If tail, send result to client and send result shuttle backwards
	#	2) If not tail, just add current result and forward it.
	# We also check if we need to inject failures in this method.

	def forward_shuttle(replica, result_shuttle, order_shuttle):
		operation = order_shuttle.operation

		slot =  order_shuttle.slot

		self.slot_list.append(slot)
		
		# This is required so that each replicas will know current slot.
		init_slot(slot)

		log.info(self.INFO + "Received shuttle from "+ str(replica) \
				+" for msg "+str(operation.msg_id))

		# Everytime we receive a shuttle from a particular client, we increment the count. This is
		# used to inject failure while shuttle is traveling down the chain 

		self.forward_shuttle_count[operation.client_id] += 1

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation, 'normal')

		log.info(self.INFO + "Hashing the result and signing the statments for msg "+ str(operation.msg_id))
		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
										operation, self.config.id), False))

		# add order shuttle to current replicas history
		self.history.append(order_shuttle)

		# Verify the order shuttle before it is sent ahead
		if (verify_shuttle(order_shuttle, "order_proof") == False):
			log.error(self.INFO + "Order shuttle verification failed for msg "+ str(operation.msg_id)\
					+", we need to ask olympus to reconfigure")
			notify_olympus(order_shuttle)
			return

		result_statement = ResultStatement(hash(result),operation)
		result_shuttle.statements.append(sign_statement(result_statement, False))
		self.latest_result[operation.client_id] = (result_statement, result)

		# Verify the result shuttle before it is sent ahead
		if (verify_shuttle(result_shuttle, "result_proof") == False):
			log.error(self.INFO + "Result shuttle verification failed msg "+ str(operation.msg_id)\
					+ ", we need to ask olympus to reconfigure")
			notify_olympus(result_shuttle)
			return

		# Unhashed result
		result_shuttle.result = result

		# This is used to inject failure.
		ret_index = is_failure_condition_satisfied(str(operation.msg_id))
		if (self.failure_config_list is not None and ret_index != -1):
			print("failure condition is satisfied for forward shuttle")
			log.info(self.INFO + "Failure Injection condition satisfied for msg "+ str(operation.msg_id))
			order_shuttle, result_shuttle = perform_failure_injection(order_shuttle, \
						result_shuttle, self.config.replica_list.index(self.config.id), ret_index)
		'''
		print("Returning index : ", ret_index)
		verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.id], encoder=nacl.encoding.HexEncoder)
				# Decrypting the result statement first
		res = pickle.loads(verify_key.verify(result_shuttle.statements[ret_index]))

		print("BUGGER : ", res.result)
		'''
		# We have to send result to client and start result shuttle message
		# backwards if it is a tail, else just forward the shuttle.
		if (self.config.is_tail):
			# We make a response object before sending
			response = ResponseObject(result_shuttle.msg_id, result, result_shuttle)

			# Cache the result and send it back
			result_cache[result_shuttle.msg_id] = result_shuttle

			self.result_shuttle_count[result_shuttle.client_id] += 1

			# When result shuttle reached tail, if we have started timer then we send 
			# result to client and stop timer
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission of msg "+ str(result_shuttle.msg_id)\
						+", sending this to" + " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()
				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)
				if (self.config.testcase_name == "testing_retransmission" or self.config.testcase_name == "forwarded_request"):
					send(("result", response), to=order_shuttle.client_id)
			
			log.info(self.INFO + "Datastore before sending to client : " + str(self.config.data_store))
			log.info(self.INFO + "Sending result to client " + str(order_shuttle.client_id) \
					+ " for msg " + str(result_shuttle.msg_id))

			if (self.config.testcase_name != "testing_retrinansmission" and self.config.testcase_name != "test_saved_cache" \
				and self.config.testcase_name != "forwarded_request"):
				send(("result", response), to=order_shuttle.client_id)
			# send result shuttle back

			send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.info(self.INFO + "Forwarding the shuttle with signed stmts to " + str(self.config.next_replica_id) \
					+ " for msg "+str(operation.msg_id))
			send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)

	# This method receives result shuttle from backward direction.
	# We verify as soon as we receive it before sending above and also we need to check
	# if we need to trigger any failures.

	def send_result_backward(result_shuttle):
		if (self.config.mode == ACTIVE and verify_shuttle(result_shuttle, "result_proof_reverse_direction") == True):

			# This is used to inject failure in result shuttle while coming back
			self.result_shuttle_count[result_shuttle.client_id] += 1
			
			result_cache[result_shuttle.msg_id] = result_shuttle
			log.info(self.INFO + "Result shuttle received for msg - " + str(result_shuttle.msg_id) + ", caching the result.")
			
			# While shuttle is going back if condition failure condition is satisfied we 
			# inject the failure. order_shuttle will be None
			ret_index = is_failure_condition_satisfied(str(result_shuttle.msg_id))
			if (self.failure_config_list is not None and ret_index != -1):
				log.info(self.INFO + "Failure Injection condition satisfied.")
				dummy, result_shuttle = perform_failure_injection(None, \
						result_shuttle, self.config.replica_list.index(self.config.id), ret_index)
			

			# We have received this result shuttle as a part of reconfig, so timers are running
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission for msg "+str(result_shuttle.msg_id)+", sending this to" + \
						  " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()

				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)
				send(("result", response), to=result_shuttle.client_id)

			# We send result back till the head.
			if (not self.config.is_head):
				send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.error(self.INFO + "Result shuttle verification failed for msg "+ str(result_shuttle.msg_id) \
					+", we need to request olympus to reconfigure")
			notify_olympus(result_shuttle)
			return

	# Helper to sign the statements that we receive
	def sign_statement(statement, make_invalid):
		if make_invalid:
			log.info(self.INFO + "Altering the signature.")
			invalid_signed = invalidate_sign(self.config.signing_key.sign(pickle.dumps(statement)))
			return invalid_signed
		else:
			return self.config.signing_key.sign(pickle.dumps(statement))

	def invalidate_sign(signed):
		signedlist = list(signed)
		signedlist[0] = (signedlist[0] + 1) % 256
		newsigned=bytes(signedlist)
		invalid_signed = nacl.signing.SignedMessage._from_parts(signed._signature, signed._message, newsigned)
		return invalid_signed

	# Helper to hash the result.
	def hash(result):
		digest = HASHER(pickle.dumps(result), encoder=nacl.encoding.HexEncoder)
		return digest

	# This method will be used by the head first time to create new shuttle and
	# forward the same to next replica. 
	# We also check for any triggers that head is supposed to carry on.

	def send_new_shuttle(operation, client):
		slot = get_next_slot()	

		log.info(self.INFO + "slot number : " + str(slot))

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation, "normal")

		# Order shuttle..
		# Create order shuttle that goes down the chain
		order_shuttle =  OrderShuttle(slot, operation, client)
		# Add the first order statement
		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
													operation, self.config.id), False))

		# add order shuttle to current replicas history
		self.history.append(order_shuttle)

		# Result shuttle..
		# Create a result shuttle that goes down the chain
		result_shuttle = ResultShuttle(client, operation.msg_id, result, operation)
		# Add the first result statement
		# TODO - Need to encrypt result

		result_statement = ResultStatement(hash(result),operation)
		result_shuttle.statements.append(sign_statement(result_statement, False))
		self.latest_result[operation.client_id] = (result_statement, result)

		# This checks if we are supposed to inject some failure before sending 
		# the shuttle ahead
		ret_index = is_failure_condition_satisfied(str(operation.msg_id))
		if (self.failure_config_list is not None and ret_index != -1 or self.tamper_next_send == True):
			log.info(self.INFO + "Failure Injection condition satisfied.")
			order_shuttle, result_shuttle = perform_failure_injection(order_shuttle, result_shuttle, 0, ret_index)
		
		log.info(self.INFO + "Hashing the result and signing the statments for msg "+ str(operation.msg_id))
		# Same send will be used for both order and result shuttle down the chain
		log.info(self.INFO + "Forwarding the shuttle with signed stmnts for msg "+ str(operation.msg_id) \
				+ " to " + str(self.config.next_replica_id))

		if (self.config.testcase_name == "testing_retransmission" or self.config.testcase_name == "forwarded_request"):
			time.sleep(10)

		send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	# This method executes the operation on the datastore
	def execute_operation(operation, type):

		if (type == 'normal'):
			data_store = self.config.data_store
		else:
			data_store = self.data_store_backup

		if (operation.type == PUT):
			data_store[operation.data.key] = [operation.data.value]
			return OK

		elif (operation.type == APPEND):
			if (operation.data.key in data_store):
				data_store[operation.data.key].append(operation.data.value)
				return OK
			return FAIL

		elif (operation.type == SLICE):
			start = int(operation.data.value.split(":")[0])
			end = int(operation.data.value.split(":")[1])

			if (operation.data.key not in data_store or start < 0 \
									or end > len(data_store)):
				return FAIL
			else:
				data_store[operation.data.key] = \
						self.config.data_store[operation.data.key][start : end]
				return OK

		elif (operation.type == GET):
			if (operation.data.value not in data_store):
				return NOT_PRESENT
			else:
				return data_store[operation.data.value]
		else:
			return ERROR

	def catch_up(longest_history):
		# we need to catch up 

		# Deep copy the datastore first
		self.data_store_backup = copy.deepcopy(self.config.data_store)
		log.info(self.INFO + "Performing operation on a backup datastore")
		
		for index in range(0,len(longest_history)):
			if (index < len(self.history)):
				continue
			else:
				operation = longest_history[index].operation
				result = execute_operation(operation, "catch_up")
				self.latest_result[operation.client_id] = (ResultStatement(hash(result),operation), result)
		log.info(self.INFO + "catch up successful, sending hash of datastore.")
		# print("After catch up sorted : ",sorted(self.config.data_store.items()))

		print("******** - ", hash(sorted(self.data_store_backup.items())))
		send(("catch_up_verification", hash(sorted(self.data_store_backup.items())), \
			self.latest_result), to=self.olympus)

	######### Receivers in replica ##########
	
	# This is a common receiver which does the following:
	# 1) Receives the main operation from client if it is a head
	# 2) Receives the order and result shuttle from prev replica
	# 3) Receive retransmission request from client
	# @args : operation - will be sent only by client for the first time,
	#		  other wise it is None, or during retransmission
	#		  shuttles - Will be sent by replicas when it is moving down the chain

	def receive(msg=("operation", operation, order_shuttle, result_shuttle), from_=sender):
		opt = None
		# This is the case when shuttle is moving down
		if (operation == None):
			opt = order_shuttle.operation
		else:																						
			# If we receive operation object then it is coming from client
			self.client_counts[sender] += 1
			opt = operation

		ret_index = is_failure_condition_satisfied(str("dummy"))
		if (self.failure_config_list is not None and ret_index != -1 and (DROP in self.failure_config_list[ret_index].opt_type)):
			log.info(self.INFO + "Failure condition satisfied for msg " + str(opt.msg_id))
			dummy1, dummy2 = perform_failure_injection(None, \
						None, self.config.replica_list.index(self.config.id), ret_index)

			if dummy1 == True or dummy2 == True:
				return

		if (self.config.mode == ACTIVE):
			handle_transmission(operation=opt, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			# TODO - Need to send error statement to client
			pass

	# Any retransmission operation from client or from other replicas to head is received here.

	def receive(msg=("retransmit_operation", operation, order_shuttle, result_shuttle), from_=sender):
		if (self.config.mode == ACTIVE):
			# If replica is head, if we receive operation request from any replica and we already started shuttle 
			# for this operation, we just ignore
			if (self.config.is_head and ("Replica" in str(sender))):
				self.forward_msg_count[self.failure_config.client_id] += 1
				log.info(self.INFO + "Received retransmission forward from replicas")

				# To check trigger for forwarded request
				
				ret_index = is_failure_condition_satisfied(str(operation.msg_id))
				if (self.failure_config_list is not None and ret_index != -1 and (DROP in self.failure_config_list[ret_index].opt_type)):
					log.info(self.INFO + "Failure Injection condition satisfied for msg "+ str(operation.msg_id))
					self.tamper_next_send = True
			else:
				handle_retransmission(operation=operation, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			# Sending None as result, which basically means error here
			response = ResponseObject(operation.msg_id, ERROR, None)
			send(("result", response), to=sender)


	# This is a receiver to receive result shuttle back from tail, we cache result here
	def receive(msg=('backward_result', result_shuttle), from_=r):

		if (self.config.mode == ACTIVE):
			send_result_backward(result_shuttle)

	# This receives failure config if this replica is supposed to inject anything
	def receive(msg=('failure_config_list', failure_config_list), from_=o):
		log.info(self.INFO + "Received failure config from olympus")
		self.failure_config_list = failure_config_list

	# This receives client details from olympus, we need this because we start
	# replicas before all clients register

	def receive(msg=('client_details', client_info, slot), from_=o):
		log.info(self.INFO + "Received client information")
		self.config.clients = client_info
		# Save the olympus info
		self.olympus = o
		init_slot(slot)
		log.info(self.INFO + "Olympus info registered : " + str(self.olympus))
		init_counts()

	# This reveiver receives message to become immutable.

	def receive(msg=("become_immutable"), from_=r):
		log.info(self.INFO + "Received message to become immutable")
		self.config.mode = IMMUTABLE

	#client sends query check that dictionary contains expected content at end of test case.
	# TODO - Need to sign here before sending

	def receive(msg=("query_data_store"), from_=client):
		log.info(self.INFO + "Received data_store query from client " + str(client))
		send(("head_data_store", self.config.data_store), to=client)
		log.info(self.INFO + "Sent data_store to requesting client " + str(client))

	def receive(msg=("checkpoint_forward", checkpoint_shuttle), from_=r):
		if (self.config.mode == ACTIVE):
			log.info(self.INFO + "Received checkpoint shuttle from " + str(r))
			handle_checkpoint("forward", checkpoint_shuttle)

	def receive(msg=("checkpoint_reverse", checkpoint_shuttle), from_=r):
		if (self.config.mode == ACTIVE):
			log.info(self.INFO + "Received checkpoint shuttle from " + str(r))
			handle_checkpoint("reverse", checkpoint_shuttle)

	# Receive request from olympus to get wedged data, this also makes the replica
	# immutable.
	def receive(msg=("wedged"), from_=o):
		log.info(self.INFO + "Received reconfig command from olympus, making wedged data and sending it to olympus.")
		wedged_data = wedgedData(self.config.id, self.history, self.checkpoint, get_current_slot())
		# TODO - signing the wedged_data
		#wedged_data = sign_statement(wedged_data)
		# increasing the wedge_count to appropriately trigger wedge_request failure
		wedge_request_count += 1

		ret_index = is_failure_condition_satisfied(str("wedge_request"))
		if (self.failure_config_list is not None and ret_index != -1 and (DROP in self.failure_config_list[ret_index].opt_type)):
			print("failure condition satisfied for wedged request, now injecting failure")
			dummy1, dummy2 = perform_failure_injection(None, \
						None, self.config.replica_list.index(self.config.id), ret_index)

			if dummy1 == True or dummy2 == True:
				return

		send(("wedged_data", wedged_data), to=self.olympus)
		log.info(self.INFO + "State changed to immutable.")
		print(self.INFO , " :  ", self.config.data_store)
		self.config.mode = IMMUTABLE

	def receive(msg=("catch_up", longest_history), from_=o):
		log.info(self.INFO + "Received request to catch up.")
		catch_up(longest_history)

	def receive(msg=("running_state"), from_=o):
		# Count to handle receipt of m'th get_running_state message failure trigger
		self.get_running_state_req_count += 1

		ret_index = is_failure_condition_satisfied(str("running_state_request"))
		if (self.failure_config_list is not None and ret_index != -1):
			print("failure condition satisfied for get_running_state request, now injecting failure")
			dummy1, dummy2 = perform_failure_injection(None, \
						None, self.config.replica_list.index(self.config.id), ret_index)

			if dummy1 == True or dummy2 == True:
				return

		log.info(self.INFO + "Received request for running state, encrypting and sending the state")
		if (len(self.data_store_backup) > 0):
			send(("running_state_data", self.data_store_backup), to=o)
		else:
			send(("running_state_data", self.config.data_store), to=o)

	def receive(msg=("get_latest_result"), from_=o):
		send(("latest_result", self.latest_result), to=o)

	def receive(msg=("exit"), from_=o):
		log.info(self.INFO + "Process killed.")
		os._exit(-1)