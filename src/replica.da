from logger import *
from classes import *
from constants import *
from timer import CustomTimer
from util import *
import nacl.encoding
import nacl.hash
import pickle
import uuid
import time
import sys

class Replica(process):

	# Main setup function that receives all the information required by replicas
	def setup(replica_config):
		# ReplicaConfig object
		self.config = replica_config
		self.client_counts = dict() # <client_id, msg_count>
		self.forward_msg_count = dict() # <client_id, forward_msg_count>
		self.shuttle_count = 0	
		self.result_shuttle_count = 0
		self.failure_config = None
		self.msg_cache = dict()
		self.forward_msg_fail = False
		self.test = False
		self.history = []
		self.result_cache = dict()
		self.forward_shuttle_count = dict()
		self.result_shuttle_count = dict()
		self.HASHER = nacl.hash.sha256
		self.INFO = "["+str(self.config.id).replace('>', "").replace('<', '')+"] "
		log.info(INFO +"Setup complete")

	def run():
		await(self.test == True)

	# This method is used to initialize all the datastructures that keeps track of
	# various message counts for each client.
	def init_counts():
		# Adds count 0 for all clients
		for key in list(self.config.clients.keys()):
			self.client_counts[key] = 0
			self.forward_msg_count[key] = 0
			self.forward_shuttle_count[key] = 0
			self.result_shuttle_count[key] = 0

	# This method verifies if client is valid
	def is_valid_client(c):
		if (c in self.config.clients):
			return True
		return False

	# This method is used by replicas to handle retransmission
	# We start a timer for every replica here and if we do not receive replicas
	# before that time then we reconfig. We have multiple cases here
	# 1) If result is cached already, we directly send it to client.
	# 2) If not we start a timer and forward that request to the head.

	def handle_retransmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		
		# Case1 - result is cached
		if (operation.msg_id in result_cache):
			log.info(self.INFO + "Result for " + str(operation.msg_id) + " is saved, sending to client" + str(sender))
			response = ResponseObject(operation.msg_id, self.result_cache[operation.msg_id].result, \
						self.result_cache[operation.msg_id])

			send(("result", response), to=sender)

		# Case2 - All other cases we will send request to head
		else:
			if (not self.config.is_head):
				# This is for forwarded message failure injection
				self.forward_msg_count[operation.client_id] += 1
				if (self.failure_config is not None):
					if (self.forward_msg_count[self.failure_config.client_id] == self.failure_config.msg_count):
						log.info(self.INFO + "Forwarded request failure condition satisfied, asking head to inject in next shuttle.")
						
						# Creates a dummy failure config that will be given to head
						failure_config = FailureConfig(self.failure_config.client_id, None, None, self.failure_config.opt_type)
						
						send(("trigger_forward_msg_failure", failure_config), to=self.config.head_id)

				# This will start a custom timer  
				log.info(self.INFO + "Starting retransmission timer and sending request to head for msg " \
						+ str(operation.msg_id))
				timer = CustomTimer(float(self.config.head_timeout), timer_callback, self.config.id, operation)
				# add the timer object to msg cache of this replica
				msg_cache[operation.msg_id] = timer
				send(("retransmit_operation", operation, None, None), to=self.config.head_id)
			else:
				# If head has already seen the message, but does not have result
				if (operation.msg_id in self.msg_cache):
					log.info(self.INFO + "Head has already seen the msg "+ str(operation.msg_id) +", so we don't start a new shuttle. \
						Let's wait for result shuttle to come back")
				else:
					# This will start a custom timer
					log.info(self.INFO + "Head has not seen the message at all.")
					log.info (self.INFO + "Starting retransmission timer and starting order shuttle down the chain for msg" \
							 + str(operation.msg_id))
					timer = CustomTimer(float(self.config.nonhead_timeout), timer_callback, self.config.id, operation)
					# add the timer object to msg cache of this replica
					msg_cache[operation.msg_id] = timer
					send_new_shuttle(operation, sender)

	# If this timer callback is invoked, our replicas are timedout on retransmission, so we
	# need to reconfigure. Currently it will also send a message for others to become immutable.

	def timer_callback(id, operation):
		log.error(self.INFO +  "TIME OUT for replica " + str(id) + " for msg"+ str(operation.msg_id) \
				+", requesting olympus to reconfigure")
		send_immutable_msg()		
		msg_cache[operation.msg_id].stop()

	# This method handles sending order shuttle down the chain
	# Here we have multiple cases based on if the replica is HEAD or Normal replicas

	def handle_transmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		if (self.config.mode == ACTIVE):
			# Case when replica is a head
			if (self.config.is_head):
				print_opt(operation)
				send_new_shuttle(operation, sender)
			# For any other case
			else:
				forward_shuttle(sender, result_shuttle, order_shuttle)

	# Helper to print		
	def print_opt(operation):
		opt = str(operation.type) + "("
		if (operation.data.key is not None): 
			opt += str(operation.data.key) + ","
		opt += str(operation.data.value)+")"
		
		log.info(self.INFO + "Received operation {" +opt+ "}" + " with msg id " +\
				str(operation.msg_id))

	# This method is used to verify the order proof before forwarding the shuttle
	# This is a common verification method for both result and order shuttle, 
	# it could be optimized

	def verify_shuttle(shuttle, shuttle_type):
		log.info(self.INFO + "Verifying " + shuttle_type)
		index = 0
		prev_res = None
		slot_or_res = []

		# This will check if there is anything dropped from statements
		if (shuttle_type == "result_proof_reverse_direction"):
			# If result is going back then it should have all replicas statements
			if (len(shuttle.statements) != len(self.config.replica_list)):
				return False
		elif (shuttle_type == "order_proof" or shuttle_type == "result_proof"):
			# If shuttle is going down then it should have enough statements
			if (len(shuttle.statements) != (self.config.replica_list.index(self.config.id)) + 1):
				return False

		# This will check if all of them have same value
		for statement in shuttle.statements:
			verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)
			index += 1
			res = pickle.loads(verify_key.verify(statement))

			if (prev_res is not None and (prev_res.operation.type != res.operation.type or \
				prev_res.operation.data.key != res.operation.data.key or \
				prev_res.operation.data.value != res.operation.data.value or \
				prev_res.operation.msg_id != res.operation.msg_id or \
				prev_res.operation.client_id != res.operation.client_id)):
				return False

			if (shuttle_type == "order_proof"):
				slot_or_res.append(res.slot)
			else:
				slot_or_res.append(res.result)

			prev_res = res

		# Slot has to be same for everyone if it is order proof or else
		# hash of result has to be same if it is res shuttle
		if (len(set(slot_or_res)) == 1):
			log.info(self.INFO + "Verification of "+ shuttle_type +" succesful for msg "\
					+str(shuttle.operation.msg_id))
			return True

		return False

	# This is the main method that checks if it is the right time to trigger
	# a failure. We use failure configration object for details.

	def is_failure_condition_satisfied(msg):
		# If replica has received 'm' messages from a particular client
		log.info(self.INFO + "checking if failure injection criteria is satisfied for msg " + msg)
		if (self.failure_config.shuttle_type == CLIENT_REQUEST):
			if (self.client_counts[self.failure_config.client_id] == self.failure_config.msg_count):
				# Making -100 so that we dont get this condition again
				self.client_counts[self.failure_config.client_id] = -100
				return True
			return False
		# If replica has received 'm' forwarded message for a particular client
		elif (self.failure_config.shuttle_type == FORWARDED_REQUEST):
			return forward_msg_fail
		# We might have to reset count here, so that someother injection 
		# does not happen becuase of this condition
		elif (self.failure_config.shuttle_type == SHUTTLE):
			if (self.forward_shuttle_count[self.failure_config.client_id] == self.failure_config.msg_count):
				self.forward_shuttle_count[self.failure_config.client_id] = -100
				return True
			else:
				return False
		elif (self.failure_config.shuttle_type == RESULT_SHUTTLE):
			if (self.result_shuttle_count[self.failure_config.client_id] == self.failure_config.msg_count):
				self.result_shuttle_count[self.failure_config.client_id] = -100
				return True
			else:
				return False
		else:
			return False

	# This method is the heart of failure injection, it does the following:
	# 1) Identifies the type of injection to be performed
	# 2) Since statements are signed, we need to decrypt them
	# 3) Add dummy operation to the respective position of the statement
	# 4) Above is repeated for both order and result shuttle

	def perform_failure_injection(order_shuttle, result_shuttle, index):
		log.info(self.INFO + "Performing failure injection - " + self.failure_config.opt_type \
				+ " for msg " + str(result_shuttle.msg_id) )
		
		# Here lets change the statement of index that is sent below in both order and result shuttle
		if (self.failure_config.opt_type == CHANGE_OPT):
			log.info(self.INFO + "Changing the operation to get(X)")
			# Decrypting the order statement first
			verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)
			
			# If trigger type is result shuttle then order shuttle received will be None
			if (order_shuttle != None):
				res = pickle.loads(verify_key.verify(order_shuttle.statements[index]))
				
				# creating a wrong operation object
				operation = Operation(GET, res.operation.msg_id, Data(None, 'X'), res.operation.client_id)

				# Modifying original order statement of this replica to something wrong
				order_shuttle.statements[index] = sign_statement(OrderStatement(res.slot, \
														operation, self.config.id))
				
			# Decrypting the result statement first
			res = pickle.loads(verify_key.verify(result_shuttle.statements[index]))
			operation = Operation(GET, res.operation.msg_id, Data(None, 'X'), res.operation.client_id)			

			# Modifying original result statement of this replica to something wrong
			result_shuttle.statements[index] = sign_statement(ResultStatement(res.result,operation))
			
		elif (self.failure_config.opt_type == DROP_RESULT):
			log.info(self.INFO + "Dropping head result statement.")
			# Drop the result statement of the head
			del result_shuttle.statements[0]
		elif (self.failure_config.opt_type == CHANGE_RES):
			log.info(self.INFO + "Adding fake hash(OK) as result hash.")

			verify_key = nacl.signing.VerifyKey(self.config.replica_keys[self.config.replica_list[index]], \
												encoder=nacl.encoding.HexEncoder)

			# Decrypting the result statement first
			res = pickle.loads(verify_key.verify(result_shuttle.statements[index]))
			# We add hash of OK always
			fake_result = hash(OK)
			# Modifying original result statement of this replica to something wrong
			result_shuttle.statements[index] = sign_statement(ResultStatement(fake_result,res.operation))

		else:
			log.info(self.INFO + "Failure injection operation not recognized")

		return order_shuttle, result_shuttle

	# This method currently sends a message to all replicas asking them to become immutable.
	def send_immutable_msg():
		for replica in self.config.replica_list:
			send(("become_immutable"), to=replica)

	# This method will be used by replicas, to add its details and send the 
	# result
	# We have 2 cases : 
	#	1) If tail, send result to client and send result shuttle backwards
	#	2) If not tail, just add current result and forward it.
	# We also check if we need to inject failures in this method.

	def forward_shuttle(replica, result_shuttle, order_shuttle):
		operation = order_shuttle.operation

		slot =  order_shuttle.slot
		log.info(self.INFO + "Received shuttle from "+ str(replica) \
				+" for msg "+str(operation.msg_id))

		# Everytime we receive a shuttle from a particular client, we increment the count. This is
		# used to inject failure while shuttle is traveling down the chain 

		self.forward_shuttle_count[operation.client_id] += 1

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation)

		log.info(self.INFO + "Hashing the result and signing the statments for msg "+ str(operation.msg_id))
		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
										operation, self.config.id)))

		# Verify the order shuttle before it is sent ahead
		if (verify_shuttle(order_shuttle, "order_proof") == False):
			log.error(self.INFO + "Order shuttle verification failed for msg "+ str(operation.msg_id)\
					+", we need to ask olympus to reconfigure")
			send_immutable_msg()
			return

		result_shuttle.statements.append(sign_statement(ResultStatement(hash(result), \
														operation)))
		
		# Verify the result shuttle before it is sent ahead
		if (verify_shuttle(result_shuttle, "result_proof") == False):
			log.error(self.INFO + "Result shuttle verification failed msg "+ str(operation.msg_id)\
					+ ", we need to ask olympus to reconfigure")
			send_immutable_msg()
			return

		# Unhashed result
		result_shuttle.result = result

		# This is used to inject failure.
		if ((self.failure_config is not None and is_failure_condition_satisfied(str(operation.msg_id))) \
																	or self.forward_msg_fail is True):

			log.info(self.INFO + "Failure Injection condition satisfied for msg "+ str(operation.msg_id))
			order_shuttle, result_shuttle = perform_failure_injection(order_shuttle, \
						result_shuttle, self.config.replica_list.index(self.config.id))

		# add order shuttle to current replicas history
		history.append(order_shuttle)

		# We have to send result to client and start result shuttle message
		# backwards if it is a tail, else just forward the shuttle.
		if (self.config.is_tail):
			# We make a response object before sending
			response = ResponseObject(result_shuttle.msg_id, result, result_shuttle)

			# Cache the result and send it back
			result_cache[result_shuttle.msg_id] = result_shuttle

			self.result_shuttle_count[result_shuttle.client_id] += 1

			# When result shuttle reached tail, if we have started timer then we send 
			# result to client and stop timer
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission of msg "+ str(result_shuttle.msg_id)\
						+", sending this to" + " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()
				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)
				if (self.config.testcase_name == "testing_retransmission"):
					send(("result", response), to=order_shuttle.client_id)
			
			log.info(self.INFO + "Datastore before sending to client : " + str(self.config.data_store))
			log.info(self.INFO + "Sending result to client " + str(order_shuttle.client_id) \
					+ " for msg " + str(result_shuttle.msg_id))

			if (self.config.testcase_name != "testing_retransmission" and self.config.testcase_name != "test_saved_cache"):
				send(("result", response), to=order_shuttle.client_id)
			# send result shuttle back

			send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.info(self.INFO + "Forwarding the shuttle with signed stmts to " + str(self.config.next_replica_id) \
					+ " for msg "+str(operation.msg_id))
			send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)

	# This method receives result shuttle from backward direction.
	# We verify as soon as we receive it before sending above and also we need to check
	# if we need to trigger any failures.

	def send_result_backward(result_shuttle):
		if (self.config.mode == ACTIVE and verify_shuttle(result_shuttle, "result_proof_reverse_direction") == True):

			# This is used to inject failure in result shuttle while coming back
			self.result_shuttle_count[result_shuttle.client_id] += 1
			
			result_cache[result_shuttle.msg_id] = result_shuttle
			log.info(self.INFO + "Result shuttle received for msg - " + str(result_shuttle.msg_id) + ", caching the result.")
			
			# While shuttle is going back if condition failure condition is satisfied we 
			# inject the failure. order_shuttle will be None

			if (self.failure_config is not None and is_failure_condition_satisfied(str(result_shuttle.msg_id))):
				log.info(self.INFO + "Failure Injection condition satisfied.")
				dummy, result_shuttle = perform_failure_injection(None, \
						result_shuttle, self.config.replica_list.index(self.config.id))

			# We send result back till the head.
			if (not self.config.is_head):
				send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.error(self.INFO + "Result shuttle verification failed for msg "+ str(result_shuttle.msg_id) \
					+", we need to request olympus to reconfigure")
			send_immutable_msg()
			return

	# Helper to sign the statements that we receive
	def sign_statement(statement):
		return self.config.signing_key.sign(pickle.dumps(statement))

	# Helper to hash the result.
	def hash(result):
		digest = HASHER(pickle.dumps(result), encoder=nacl.encoding.HexEncoder)
		return digest

	# This method will be used by the head first time to create new shuttle and
	# forward the same to next replica. 
	# We also check for any triggers that head is supposed to carry on.

	def send_new_shuttle(operation, client):
		slot = get_next_slot()

		# If entry is already there then its retransmission and timer is started already
		if (operation.msg_id not in msg_cache):
			self.msg_cache[operation.msg_id] = None

		# Execute the necessary operations
		result = execute_operation(operation)

		# Order shuttle..
		# Create order shuttle that goes down the chain
		order_shuttle =  OrderShuttle(slot, operation, client)
		# Add the first order statement
		order_shuttle.statements.append(sign_statement(OrderStatement(slot, \
													operation, self.config.id)))

		# Result shuttle..
		# Create a result shuttle that goes down the chain
		result_shuttle = ResultShuttle(client, operation.msg_id, result, operation)
		# Add the first result statement
		# TODO - Need to encrypt result
		result_shuttle.statements.append(sign_statement(ResultStatement(hash(result), \
													operation)))

		# This checks if we are supposed to inject some failure before sending 
		# the shuttle ahead

		if ((self.failure_config is not None and is_failure_condition_satisfied(str(operation.msg_id))) or self.forward_msg_fail is True):
			log.info(self.INFO + "Failure Injection condition satisfied.")
			order_shuttle, result_shuttle = perform_failure_injection(order_shuttle, result_shuttle, 0)

		# add order shuttle to current replicas history
		history.append(order_shuttle)

		log.info(self.INFO + "Hashing the result and signing the statments for msg "+ str(operation.msg_id))
		# Same send will be used for both order and result shuttle down the chain
		log.info(self.INFO + "Forwarding the shuttle with signed stmnts for msg "+ str(operation.msg_id) \
				+ " to " + str(self.config.next_replica_id))

		if (self.config.testcase_name == "testing_retransmission"):
			time.sleep(10)

		send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	# This method executes the operation on the datastore
	def execute_operation(operation):
		if (operation.type == PUT):
			self.config.data_store[operation.data.key] = [operation.data.value]
			return OK

		elif (operation.type == APPEND):
			if (operation.data.key in self.config.data_store):
				self.config.data_store[operation.data.key].append(operation.data.value)
				return OK
			return FAIL

		elif (operation.type == SLICE):
			start = int(operation.data.value.split(":")[0])
			end = int(operation.data.value.split(":")[1])

			if (operation.data.key not in self.config.data_store or start < 0 \
									or end > len(self.config.data_store)):
				return FAIL
			else:
				self.config.data_store[operation.data.key] = \
						self.config.data_store[operation.data.key][start : end]
				return OK

		elif (operation.type == GET):
			if (operation.data.value not in self.config.data_store):
				return NOT_PRESENT
			else:
				return self.config.data_store[operation.data.value]

		else:
			return ERROR

	######### Receivers in replica ##########
	
	# This is a common receiver which does the following:
	# 1) Receives the main operation from client if it is a head
	# 2) Receives the order and result shuttle from prev replica
	# 3) Receive retransmission request from client
	# @args : operation - will be sent only by client for the first time,
	#		  other wise it is None, or during retransmission
	#		  shuttles - Will be sent by replicas when it is moving down the chain

	def receive(msg=("operation", operation, order_shuttle, result_shuttle), from_=sender):
		opt = None
		# This is the case when shuttle is moving down
		if (operation == None):
			opt = order_shuttle.operation
		else:
			# If we receive operation object then it is coming from client
			self.client_counts[sender] += 1
			#print("*************",self.client_counts)
			opt = operation

		if (self.config.mode == ACTIVE):
			handle_transmission(operation=opt, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			# TODO - Need to send error statement to client
			pass

	# Any retransmission operation from client or from other replicas to head is received here.

	def receive(msg=("retransmit_operation", operation, order_shuttle, result_shuttle), from_=sender):
		if (self.config.mode == ACTIVE):
			# If replica is head, if we receive operation request from any replica and we already started shuttle 
			# for this operation, we just ignore
			if (self.config.is_head and ("Replica" in str(sender))): #and self.msg_cache[operation.msg_id] is not None):
				log.info(self.INFO + "Received retransmission forward from replicas")
				pass
			else:
				handle_retransmission(operation=operation, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
		else:
			# Sending None as result, which basically means error here
			response = ResponseObject(operation.msg_id, ERROR, None)
			send(("result", response), to=sender)


	# This is a receiver to receive result shuttle back from tail, we cache result here
	def receive(msg=('backward_result', result_shuttle), from_=r):
		if (self.config.mode == ACTIVE):
			# We have received this result shuttle as a part of reconfig, so timers are running
			if (self.msg_cache[result_shuttle.msg_id] is not None):
				# Stop the running timer
				log.info(self.INFO + "Result received for retransmission, sending this to" + \
						  " client before caching it")
				self.msg_cache[result_shuttle.msg_id].stop()
				response = ResponseObject(result_shuttle.msg_id, SUCCESS, result_shuttle)
				send(("result", response), to=result_shuttle.client_id)

			send_result_backward(result_shuttle)

	# This receives failure config if this replica is supposed to inject anything
	def receive(msg=('failure_config', failure_config), from_=o):
		log.info(self.INFO + "Received failure config from olympus")
		log.info(self.INFO + "Failure config : client id-" + str(failure_config.client_id) + \
				", msg_count-" + str(failure_config.msg_count) + ", type-" + \
				failure_config.shuttle_type +", operation-" + \
				failure_config.opt_type)

		self.failure_config = failure_config

	# This receives client details from olympus, we need this because we start
	# replicas before all clients register

	def receive(msg=('client_details', client_info), from_=o):
		log.info(self.INFO + "Received client information")
		self.config.clients = client_info
		init_counts()

	# This is used by head for forwarded message failue injection
	def receive(msg=('trigger_forward_msg_failure', failure_config), from_=r):
		log.info(self.INFO + "Received request to inject failure")
		self.forward_msg_fail = True
		self.failure_config = failure_config

	# This reveiver receives message to become immutable.

	def receive(msg=("become_immutable"), from_=r):
		log.info(self.INFO + "Received message to become immutable")
		self.config.mode = IMMUTABLE

	#client sends query check that dictionary contains expected content at end of test case.
	# TODO - Need to sign here before sending

	def receive(msg=("query_data_store"), from_=client):
		log.info(self.INFO + "Received data_store query from client " + str(client))
		send(("head_data_store", self.config.data_store), to=client)
		log.info(self.INFO + "Sent data_store to requesting client " + str(client))