from logger import *
from classes import *
from constants import *
from util import *
import pickle
import uuid
import time
import sys

class Replica(process):

	def setup(replica_config):
		# ReplicaConfig object
		self.config = replica_config
		self.msg_cache = []
		self.test = False
		self.history = []
		self.result_cahce = dict()
		self.INFO = "["+str(self.config.id).replace('>', "").replace('<', '')+"] "
		log.info(INFO +"Setup complete")

	# Need to define till when replicas are up and running

	def run():
		await(self.test == True)

	# This method verifies if client is valid

	def is_valid_client(c):
		if (c in self.config.clients):
			return True
		return False

	# This method is used by replicas to handle retransmission
	# We start a timer for every replica here and if we do not receive replicas
	# before that time then we reconfig. We have multiple cases here
	def handle_retransmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		print("Sending result ###################")
		response = ResponseObject(operation.msg_id, None, self.result_cahce[operation.msg_id])
		send(("result", response), to=sender)

	# This method handles sending order shuttle down the chain
	# Here we have multiple cases based on if the replica is HEAD or TAIL

	def handle_transmission(operation=None, sender=None, result_shuttle=None, order_shuttle=None):
		# Case when replica is a head
		if (self.config.is_head):		
			print_opt(operation)
			#send_result(c, operation.msg_id)
			send_new_shuttle(operation, sender)
		# For any other case
		else:
			forward_shuttle(sender, result_shuttle, order_shuttle)

	# Helper to print		
	def print_opt(operation):
		opt = str(operation.type) + "("
		if (operation.data.key is not None): 
			opt += str(operation.data.key) + ","
		opt += str(operation.data.value)+")"
		
		log.info(self.INFO + "Received operation {" +opt+ "}")

	# This method will be used by replicas, to add its details and send the 
	# result
	# We have 2 cases : 
	#	1) If tail, send result to client
	#	2) If not tail, just add current result and forward it.

	def forward_shuttle(replica, result_shuttle, order_shuttle):
		operation = order_shuttle.operation
		slot =  order_shuttle.slot
		log.info(self.INFO + "Received shuttle from "+ str(replica))

		self.msg_cache.append(operation.msg_id)
		# Execute the necessary operations
		result = execute_operation(operation)

		# TODO : Need to verify order statements and result statements here

		order_shuttle.order_statement.append(sign_statement(OrderStatement(slot, \
														operation, self.config.id)))
		result_shuttle.statements.append(sign_statement(ResultStatement(result, \
														operation)))
		# add order shuttle to current replicas history
		history.append(order_shuttle)

		# We have to send result to client and start result shuttle message
		# backwards if it is a tail, else just forward the shuttle.
		if (self.config.is_tail):
			log.info(self.INFO + "Sending result to client " + str(order_shuttle.client_id))
			# We make a response object before sending
			response = ResponseObject(order_shuttle.operation.msg_id, result, result_shuttle.statements)
			# sending the result to client

			send(("result", response), to=order_shuttle.client_id)

			# Cache the result and send it back
			result_cahce[result_shuttle.msg_id] = result_shuttle.statements
			send(("backward_result", result_shuttle), to=self.config.prev_replica_id)
		else:
			log.info(self.INFO + "Forwarding the shuttle to " + str(self.config.next_replica_id))
			send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	def send_result_backward(result_shuttle):
		# If result shuttle is valid, then we save it in cache
		if (verify_result(result_shuttle)):
			result_cahce[result_shuttle.msg_id] = result_shuttle.statements
			log.info(self.INFO + "Result shuttle received back for msg - " + str(result_shuttle.msg_id) + ", caching the result.")
			# We send result back till the head.
			if (not self.config.is_head):
				send(("backward_result", result_shuttle), to=self.config.prev_replica_id)

	def sign_statement(statement):
		#return statement
		return self.config.signing_key.sign(pickle.dumps(statement))

	# This method will be used by the head first time to create new shuttle and
	# forward the same to next replica.

	def send_new_shuttle(operation, client):
		slot = get_next_slot()
		self.msg_cache.append(operation.msg_id)

		# Execute the necessary operations
		result = execute_operation(operation)

		# Order shuttle..
		# Create order shuttle that goes down the chain
		order_shuttle =  OrderShuttle(slot, operation, client)
		# Add the first order statement
		order_shuttle.order_statement.append(sign_statement(OrderStatement(slot, \
													operation, self.config.id)))

		# Result shuttle..
		# Create a result shuttle that goes down the chain
		result_shuttle = ResultShuttle(client, operation.msg_id)
		# Add the first result statement
		# TODO - Need to encrypt result
		result_shuttle.statements.append(sign_statement(ResultStatement(result, \
													operation)))

		# add order shuttle to current replicas history
		history.append(order_shuttle)

		# Same send will be used for both order and result shuttle down the chain
		log.info(self.INFO + "Forwarding the shuttle to " + str(self.config.next_replica_id))
		send(("operation", None, order_shuttle, result_shuttle), to=self.config.next_replica_id)


	# This method executes the operation on the datastore
	def execute_operation(operation):
		if (operation.type == PUT):
			self.config.data_store[operation.data.key] = [operation.data.value]
			return OK

		elif (operation.type == APPEND):
			if (operation.data.key in self.config.data_store):
				self.config.data_store[operation.data.key].append(operation.data.value)
				return OK
			return FAIL

		elif (operation.type == SLICE):
			start = int(operation.data.value.split(":")[0])
			end = int(operation.data.value.split(":")[1])

			if (operation.data.key not in self.config.data_store or start < 0 \
									or end > len(self.config.data_store)):
				return FAIL
			else:
				self.config.data_store[operation.data.key] = \
						self.config.data_store[operation.data.key][start : end]
				return OK

		elif (operation.type == GET):
			if (operation.data.value not in self.config.data_store):
				return NOT_PRESENT
			else:
				return self.config.data_store[operation.data.value]

	def verify_result(result_shuttle):
		return True

	######### Receivers in replica ##########
	
	# This is a common receiver which does the following:
	# 1) Receives the main operation from client if it is a head
	# 2) Receives the order and result shuttle from prev replica
	# 3) Receive retransmission request from client
	# @args : operation - will be sent only by client for the first time,
	#		  other wise it is None, or during retransmission
	#		  shuttles - Will be sent by replicas when it is moving down the chain

	def receive(msg=("operation", operation, order_shuttle, result_shuttle), from_=sender):
		opt = None
		# This is the case when shuttle is moving down
		if (operation == None):
			opt = order_shuttle.operation
		else:
			opt = operation

		if (self.config.mode == ACTIVE):
			if (opt.msg_id in msg_cache):
				handle_retransmission(operation=opt, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)
			else:
				handle_transmission(operation=opt, sender=sender, result_shuttle=result_shuttle, \
									order_shuttle=order_shuttle)

	# This is a receiver to receive result shuttle back from tail, we cache result here
	def receive(msg=('backward_result', result_shuttle), from_=r):
		if (self.config.mode == ACTIVE):
			send_result_backward(result_shuttle)